#!/usr/bin/env bash
set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

success() {
    echo -e "${GREEN}$1${NC}"
}

info() {
    echo -e "${BLUE}$1${NC}"
}

warning() {
    echo -e "${YELLOW}$1${NC}"
}

# Find the root directory (where .bare is located)
find_root() {
    local current_dir="$PWD"
    while [[ "$current_dir" != "/" ]]; do
        if [[ -d "$current_dir/.bare" ]]; then
            echo "$current_dir"
            return 0
        fi
        current_dir="$(dirname "$current_dir")"
    done
    return 1
}

# Get the default branch of a repository
get_default_branch() {
    local bare_dir="$1"
    git --git-dir="$bare_dir" symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'
}

# Generate URL-safe slug from branch name
generate_branch_slug() {
    local branch="$1"
    echo "$branch" | tr '[:upper:]/' '[:lower:]-' | \
        sed 's/[^a-z0-9-]/-/g' | \
        sed 's/--*/-/g' | \
        sed 's/^-//' | \
        sed 's/-$//'
}

# Fetch PR information and return the head ref (branch name)
get_pr_branch() {
    local pr_number="$1"
    local bare_dir="$2"
    
    # Check if gh CLI is available
    if ! command -v gh &> /dev/null; then
        error "gh CLI is required for PR support. Install from https://cli.github.com/"
    fi
    
    # Get PR head ref using gh CLI
    # We need to run this from within the repository context
    local head_ref=$(git --git-dir="$bare_dir" remote get-url origin | sed 's/.*://;s/\.git$//' | xargs -I {} gh pr view "$pr_number" --repo {} --json headRefName --jq '.headRefName' 2>/dev/null)
    
    if [[ -z "$head_ref" ]]; then
        error "Could not fetch PR #$pr_number. Make sure the PR exists and you have access to it."
    fi
    
    echo "$head_ref"
}

# Convert org/repo format to git@github.com:org/repo.git
convert_gh_format() {
    local repo="$1"
    if [[ "$repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ ]]; then
        echo "git@github.com:${repo}.git"
    else
        echo "$repo"
    fi
}

# Run a hook if it exists
run_hook() {
    local hook_name="$1"
    local worktree_dir="$2"
    local root_dir="$3"

    local hook_file="$root_dir/.worktree/hooks/$hook_name"

    # Check if hook exists and is executable
    if [[ -f "$hook_file" && -x "$hook_file" ]]; then
        info "Running $hook_name hook..."

        # Export environment variables for the hook
        export WT_ROOT_DIRECTORY="$root_dir"
        export WT_DIRECTORY="$worktree_dir"
        export WT_BRANCH="$(basename "$worktree_dir")"
        export WT_BRANCH_SLUG="$(generate_branch_slug "$WT_BRANCH")"

        # Run the hook preserving the current environment
        (cd "$worktree_dir" && "$hook_file") || {
            warning "Hook $hook_name failed (exit code: $?)"
            return 1
        }

        success "Hook $hook_name completed"
        return 0
    fi

    return 0
}

# Init command: Clone or create a bare repository
cmd_init() {
    local repo=""
    local dir=""
    local create_new=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --new)
                create_new=true
                shift
                ;;
            *)
                if [[ -z "$repo" ]]; then
                    repo="$1"
                elif [[ -z "$dir" ]]; then
                    dir="$1"
                else
                    error "Too many arguments. Usage: gh wt init <repo> [dir] [--new]"
                fi
                shift
                ;;
        esac
    done

    # Validate arguments
    if [[ -z "$repo" ]]; then
        error "Repository is required. Usage: gh wt init <repo> [dir] [--new]"
    fi

    # If dir is not provided, extract from repo
    if [[ -z "$dir" ]]; then
        dir="$(basename "$repo" .git)"
    fi

    # Check if directory already exists
    if [[ -d "$dir" ]]; then
        error "Directory '$dir' already exists"
    fi

    # Create directory
    info "Creating directory: $dir"
    mkdir -p "$dir"
    cd "$dir"

    local bare_dir=".bare"
    local git_url=$(convert_gh_format "$repo")

    if [[ "$create_new" == true ]]; then
        # Create new bare repository
        info "Creating new bare repository..."
        git init --bare "$bare_dir"

        # Add remote origin
        info "Adding remote origin: $git_url"
        git --git-dir="$bare_dir" remote add origin "$git_url"

        # Create initial commit on main branch
        info "Creating initial commit..."
        local temp_dir=$(mktemp -d)
        git --git-dir="$bare_dir" worktree add "$temp_dir" --detach
        cd "$temp_dir"
        git checkout -b main
        echo "# $(basename "$dir")" > README.md
        git add README.md
        git commit -m "Initial commit"
        git push -u origin main
        cd - > /dev/null
        git --git-dir="$bare_dir" worktree remove "$temp_dir"

        # Set HEAD to main
        git --git-dir="$bare_dir" symbolic-ref HEAD refs/heads/main

        success "Created new repository in '$dir'"
    else
        # Clone existing repository as bare
        info "Cloning repository as bare: $git_url"
        git clone --bare "$git_url" "$bare_dir"
        success "Cloned repository to '$dir'"
    fi

    # Get default branch
    local default_branch=$(get_default_branch "$bare_dir")
    if [[ -z "$default_branch" ]]; then
        default_branch="main"
    fi

    info "Creating worktree for default branch: $default_branch"

    # Create worktree for default branch using our create command
    # We need to be in the right directory for this
    export WT_ROOT_DIRECTORY="$PWD"
    git --git-dir="$bare_dir" worktree add "$default_branch" "$default_branch" 2>/dev/null || \
        git --git-dir="$bare_dir" worktree add "$default_branch" -b "$default_branch" "origin/$default_branch" 2>/dev/null || \
        git --git-dir="$bare_dir" worktree add "$default_branch" -b "$default_branch"

    # Initialize submodules if present
    if [[ -f "$default_branch/.gitmodules" ]]; then
        info "Initializing submodules..."
        (cd "$default_branch" && git submodule update --init --recursive)
    fi

    # Process templates if they exist
    if [[ -d ".worktree/templates" ]]; then
        info "Processing templates..."
        process_templates "$default_branch" "$default_branch" "$PWD"
    fi

    success "Initialization complete!"
    info "Default worktree created at: $dir/$default_branch"
    info ""
    info "Next steps:"
    info "  cd $dir/$default_branch"
    info "  # Start working on your code"
    info ""
    info "To create a new worktree:"
    info "  cd $dir"
    info "  gh wt create <branch>                    # for existing branch"
    info "  gh wt create <base-branch> <new-branch>  # for new branch"
}

# Process template files with variable replacement
process_templates() {
    local worktree_dir="$1"
    local branch_name="$2"
    local root_dir="$3"

    local templates_dir="$root_dir/.worktree/templates"

    if [[ ! -d "$templates_dir" ]]; then
        return 0
    fi

    info "Copying and processing templates..."

    # Find all files in templates directory
    find "$templates_dir" -type f | while read -r template_file; do
        # Get relative path
        local rel_path="${template_file#$templates_dir/}"
        local dest_file="$worktree_dir/$rel_path"

        # Create directory if needed
        mkdir -p "$(dirname "$dest_file")"

        # Copy and process template
        local content=$(cat "$template_file")

        # Replace variables
        local branch_slug=$(generate_branch_slug "$branch_name")
        content="${content//\$\{WT_BRANCH\}/$branch_name}"
        content="${content//\$\{WT_BRANCH_SLUG\}/$branch_slug}"
        content="${content//\$\{WT_DIRECTORY\}/$worktree_dir}"
        content="${content//\$\{WT_ROOT_DIRECTORY\}/$root_dir}"

        # Write processed content
        echo "$content" > "$dest_file"

        info "  Processed: $rel_path"
    done
}

# Create command: Create a new worktree
cmd_create() {
    local base_branch="$1"
    local new_branch="$2"

    # Validate arguments
    if [[ -z "$base_branch" ]]; then
        error "Usage: gh wt create <branch> [new-branch-name]"
    fi

    # Find root directory
    local root_dir=$(find_root)
    if [[ -z "$root_dir" ]]; then
        error "Not in a worktree-managed repository. Run 'gh wt init' first."
    fi

    local bare_dir="$root_dir/.bare"
    
    # Check if base_branch is a PR reference (pr/NUMBER or pr/NUMBER/CUSTOM-NAME)
    if [[ "$base_branch" =~ ^pr/([0-9]+)(/(.+))?$ ]]; then
        local pr_number="${BASH_REMATCH[1]}"
        local custom_name="${BASH_REMATCH[3]}"
        
        info "Fetching PR #$pr_number information..."
        
        # Fetch the PR branch name
        local pr_branch=$(get_pr_branch "$pr_number" "$bare_dir")
        
        info "PR #$pr_number uses branch: $pr_branch"
        
        # Fetch the PR branch from remote
        git --git-dir="$bare_dir" fetch origin "$pr_branch:$pr_branch" 2>/dev/null || \
            git --git-dir="$bare_dir" fetch origin "$pr_branch" 2>/dev/null || true
        
        # Determine the worktree name
        if [[ -n "$custom_name" ]]; then
            # User provided custom name: pr/123/my-feature -> my-feature
            base_branch="$pr_branch"
            new_branch="$custom_name"
        elif [[ -n "$new_branch" ]]; then
            # Two args provided: pr/123 feature-branch -> create new branch from PR
            base_branch="$pr_branch"
            # new_branch already set
        else
            # Single arg: pr/123 -> checkout PR branch as pr-123
            base_branch="$pr_branch"
            new_branch="pr-$pr_number"
        fi
    fi

    # Determine if we're adding an existing branch or creating a new one
    if [[ -z "$new_branch" ]]; then
        # Single argument: add worktree for existing branch
        local branch_name="$base_branch"
        local worktree_dir="$root_dir/$branch_name"

        # Check if worktree already exists
        if [[ -d "$worktree_dir" ]]; then
            error "Worktree directory '$branch_name' already exists"
        fi

        # Check if branch exists (local or remote)
        local branch_ref=""
        if git --git-dir="$bare_dir" show-ref --verify --quiet "refs/heads/$branch_name"; then
            # Local branch exists
            branch_ref="$branch_name"
            info "Adding worktree for existing local branch '$branch_name'..."
        elif git --git-dir="$bare_dir" show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
            # Remote branch exists - create local tracking branch
            branch_ref="origin/$branch_name"
            info "Adding worktree for remote branch '$branch_name'..."
        else
            error "Branch '$branch_name' does not exist locally or on remote. Use 'gh wt create <base-branch> <new-branch>' to create a new branch."
        fi

        # Add worktree for existing branch
        if [[ "$branch_ref" == "origin/$branch_name" ]]; then
            # Create local branch tracking remote
            git --git-dir="$bare_dir" worktree add "$worktree_dir" -b "$branch_name" "$branch_ref"
        else
            # Use existing local branch
            git --git-dir="$bare_dir" worktree add "$worktree_dir" "$branch_ref"
        fi
    else
        # Two arguments: create new branch from base
        local worktree_dir="$root_dir/$new_branch"

        # Check if worktree already exists
        if [[ -d "$worktree_dir" ]]; then
            error "Worktree directory '$new_branch' already exists"
        fi

        # Check if branch already exists
        if git --git-dir="$bare_dir" show-ref --verify --quiet "refs/heads/$new_branch"; then
            error "Branch '$new_branch' already exists. Use 'gh wt create $new_branch' to add a worktree for it."
        fi

        info "Creating worktree '$new_branch' from '$base_branch'..."

        # Create worktree
        # Try to create from the base branch (handles both local and remote branches)
        if git --git-dir="$bare_dir" show-ref --verify --quiet "refs/heads/$base_branch"; then
            # Local branch exists
            git --git-dir="$bare_dir" worktree add "$worktree_dir" -b "$new_branch" "$base_branch"
        elif git --git-dir="$bare_dir" show-ref --verify --quiet "refs/remotes/$base_branch"; then
            # Remote branch exists (already includes origin/)
            git --git-dir="$bare_dir" worktree add "$worktree_dir" -b "$new_branch" "$base_branch"
        elif git --git-dir="$bare_dir" show-ref --verify --quiet "refs/remotes/origin/$base_branch"; then
            # Remote branch exists with origin/ prefix
            git --git-dir="$bare_dir" worktree add "$worktree_dir" -b "$new_branch" "origin/$base_branch"
        else
            # Try as a commit/tag/ref
            git --git-dir="$bare_dir" worktree add "$worktree_dir" -b "$new_branch" "$base_branch" 2>/dev/null || \
                error "Could not find base branch/ref '$base_branch'"
        fi
    fi

    # Initialize submodules if present
    if [[ -f "$worktree_dir/.gitmodules" ]]; then
        info "Initializing submodules..."
        (cd "$worktree_dir" && git submodule update --init --recursive)
    fi

    # Determine the branch name for templates and hooks
    local branch_for_templates="${new_branch:-$branch_name}"

    # Process templates
    process_templates "$worktree_dir" "$branch_for_templates" "$root_dir"

    # Run post-create hook
    run_hook "post-create" "$worktree_dir" "$root_dir"

    success "Worktree created successfully!"
    info "Location: $worktree_dir"
    info ""
    info "To start working:"
    info "  cd $worktree_dir"
}

# Delete command: Delete a worktree
cmd_delete() {
    local branch_name=""
    local force=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force|-f)
                force=true
                shift
                ;;
            *)
                if [[ -z "$branch_name" ]]; then
                    branch_name="$1"
                else
                    error "Too many arguments. Usage: gh wt delete <branch-name> [--force]"
                fi
                shift
                ;;
        esac
    done

    # If no branch name provided, try to use current directory name
    if [[ -z "$branch_name" ]]; then
        branch_name="$(basename "$PWD")"
        warning "No branch specified, using current directory: $branch_name"
    fi

    # Find root directory
    local root_dir=$(find_root)
    if [[ -z "$root_dir" ]]; then
        error "Not in a worktree-managed repository."
    fi

    local bare_dir="$root_dir/.bare"
    local worktree_dir="$root_dir/$branch_name"

    # Check if worktree exists
    if [[ ! -d "$worktree_dir" ]]; then
        error "Worktree '$branch_name' does not exist"
    fi

    # Check if we're currently in the worktree we're trying to delete
    if [[ "$PWD" == "$worktree_dir"* ]]; then
        error "Cannot delete the current worktree. Please navigate to a different directory first."
    fi

    # Check for uncommitted changes unless force flag is set
    if [[ "$force" == false ]]; then
        cd "$worktree_dir"
        if ! git diff-index --quiet HEAD -- 2>/dev/null; then
            error "Worktree has uncommitted changes. Use --force to delete anyway."
        fi

        # Check for untracked files
        if [[ -n "$(git ls-files --others --exclude-standard)" ]]; then
            warning "Worktree has untracked files."
            read -p "Continue with deletion? (y/N): " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                info "Deletion cancelled."
                exit 0
            fi
        fi
        cd - > /dev/null
    fi

    info "Deleting worktree: $branch_name"

    # Run post-delete hook before removing the worktree
    run_hook "post-delete" "$worktree_dir" "$root_dir"

    # Remove worktree
    git --git-dir="$bare_dir" worktree remove "$worktree_dir" ${force:+--force}

    # Delete branch
    if git --git-dir="$bare_dir" show-ref --verify --quiet "refs/heads/$branch_name"; then
        info "Deleting branch: $branch_name"
        git --git-dir="$bare_dir" branch ${force:+-D}${force:false:-d} "$branch_name" 2>/dev/null || true
    fi

    # Prune worktrees
    git --git-dir="$bare_dir" worktree prune

    success "Worktree '$branch_name' deleted successfully!"
}

# List command: List all worktrees
cmd_list() {
    # Find root directory
    local root_dir=$(find_root)
    if [[ -z "$root_dir" ]]; then
        error "Not in a worktree-managed repository."
    fi

    local bare_dir="$root_dir/.bare"

    info "Worktrees in $root_dir:"
    echo ""

    git --git-dir="$bare_dir" worktree list
}

# Help command
cmd_help() {
    cat << EOF
gh-wt: Git worktree management for GitHub CLI

USAGE:
  gh wt <command> [arguments]

COMMANDS:
  init <repo> [dir] [--new]
      Initialize a new worktree-managed repository

      Arguments:
        repo    Repository in format 'org/repo' or full git URL
        dir     Directory name (optional, defaults to repo name)
        --new   Create a new repository instead of cloning

      Examples:
        gh wt init myorg/myrepo
        gh wt init git@github.com:myorg/myrepo.git
        gh wt init myorg/newproject --new

  create <branch> [new-branch-name]
      Create a worktree for an existing branch, or create a new branch

      Arguments:
        branch            Existing branch to add worktree for, OR base branch when creating new
        new-branch-name   (Optional) Name for the new branch and directory

      Examples:
        gh wt create feature-123              # Add worktree for existing branch
        gh wt create main feature-123         # Create new branch from main
        gh wt create origin/develop fix-456   # Create new branch from remote
        gh wt create v1.0.0 hotfix-security   # Create new branch from tag
        gh wt create pr/123                   # Create branch 'pr-123' from PR #123
        gh wt create pr/456/my-changes        # Create branch 'my-changes' from PR #456
        gh wt create pr/789 new-branch        # Create branch 'new-branch' from PR #789

  delete <branch-name> [--force]
      Delete a worktree and its branch

      Arguments:
        branch-name   Name of the branch/worktree to delete
        --force, -f   Force deletion even with uncommitted changes

      Examples:
        gh wt delete feature-123
        gh wt delete old-branch --force

  list
      List all worktrees in the current repository

      Example:
        gh wt list

  help
      Show this help message

TEMPLATE SUPPORT:
  Create a .worktree/templates directory in your repository root to define
  template files that will be copied to each new worktree.

  Available variables:
    \${WT_BRANCH}           - The branch name
    \${WT_BRANCH_SLUG}      - URL-safe branch name (lowercase, alphanumeric + hyphens)
    \${WT_DIRECTORY}        - The worktree directory path
    \${WT_ROOT_DIRECTORY}   - The repository root directory

  Example .worktree/templates/.env:
    APP_URL=\${WT_BRANCH_SLUG}.myapp.test
    APP_NAME=\${WT_BRANCH}
    DATABASE_NAME=myapp_\${WT_BRANCH_SLUG}

HOOK SUPPORT:
  Create executable scripts in the .worktree directory to run custom
  logic during worktree lifecycle events.

  Available hooks:
    post-create   - Runs after a worktree is created
    post-delete   - Runs before a worktree is deleted

  Environment variables available to hooks:
    WT_ROOT_DIRECTORY - Repository root directory
    WT_DIRECTORY      - Worktree directory path
    WT_BRANCH         - Branch name
    WT_BRANCH_SLUG    - URL-safe branch name

  Example .worktree/post-create:
    #!/usr/bin/env bash
    echo "Setting up worktree for branch: \$WT_BRANCH"
    npm install
    cp .env.example .env

  Make hooks executable:
    chmod +x .worktree/post-create

EOF
}

# Main command dispatcher
main() {
    local command="$1"
    shift || true

    case "$command" in
        init)
            cmd_init "$@"
            ;;
        create)
            cmd_create "$@"
            ;;
        delete|remove|rm)
            cmd_delete "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        help|--help|-h|"")
            cmd_help
            ;;
        *)
            error "Unknown command: $command. Run 'gh wt help' for usage."
            ;;
    esac
}

main "$@"
